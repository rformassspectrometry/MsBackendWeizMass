% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MsBackendWeizMass-functions.R,
%   R/MsBackendWeizMass.R
\name{MsBackendWeizMass}
\alias{MsBackendWeizMass}
\alias{MsBackendWeizMass-class}
\alias{compounds}
\alias{backendInitialize,MsBackendWeizMass-method}
\alias{peaksVariables,MsBackendWeizMass-method}
\alias{peaksData,MsBackendWeizMass-method}
\alias{dataStorage,MsBackendWeizMass-method}
\alias{intensity<-,MsBackendWeizMass-method}
\alias{mz<-,MsBackendWeizMass-method}
\alias{reset,MsBackendWeizMass-method}
\alias{spectraData,MsBackendWeizMass-method}
\alias{spectraNames,MsBackendWeizMass-method}
\alias{spectraNames<-,MsBackendWeizMass-method}
\alias{tic,MsBackendWeizMass-method}
\alias{[,MsBackendWeizMass-method}
\alias{$<-,MsBackendWeizMass-method}
\alias{precScanNum,MsBackendWeizMass-method}
\title{MS backend accessing the WeizMass MySQL database}
\usage{
MsBackendWeizMass()

\S4method{backendInitialize}{MsBackendWeizMass}(object, dbcon, ...)

\S4method{peaksVariables}{MsBackendWeizMass}(object)

\S4method{peaksData}{MsBackendWeizMass}(object, columns = c("mz", "intensity"))

\S4method{dataStorage}{MsBackendWeizMass}(object)

\S4method{intensity}{MsBackendWeizMass}(object) <- value

\S4method{mz}{MsBackendWeizMass}(object) <- value

\S4method{reset}{MsBackendWeizMass}(object)

\S4method{spectraData}{MsBackendWeizMass}(object, columns = spectraVariables(object))

\S4method{spectraNames}{MsBackendWeizMass}(object)

\S4method{spectraNames}{MsBackendWeizMass}(object) <- value

\S4method{tic}{MsBackendWeizMass}(object, initial = TRUE)

\S4method{[}{MsBackendWeizMass}(x, i, j, ..., drop = FALSE)

\S4method{$}{MsBackendWeizMass}(x, name) <- value

\S4method{precScanNum}{MsBackendWeizMass}(object)
}
\arguments{
\item{object}{Object extending \code{MsBackendWeizMass}.}

\item{dbcon}{For \verb{backendInitialize,MsBackendWeizMass}: SQL database
connection to the WeizMass database.}

\item{...}{Additional arguments.}

\item{columns}{For \code{spectraData} accessor: optional \code{character} with column
names (spectra variables) that should be included in the
returned \code{DataFrame}. By default, all columns are returned.}

\item{value}{replacement value for \verb{<-} methods. See individual
method description or expected data type.}

\item{initial}{For \code{tic}: \code{logical(1)} whether the initially
reported total ion current should be reported, or whether the
total ion current should be (re)calculated on the actual data
(\code{initial = FALSE}).}

\item{x}{Object extending \code{MsBackendWeizMass}.}

\item{i}{For \code{[}: \code{integer}, \code{logical} or \code{character} to subset the object.}

\item{j}{For \code{[}: not supported.}

\item{drop}{For \code{[}: not considered.}

\item{name}{name of the variable to replace for \verb{<-} methods. See individual
method description or expected data type.}

\item{spectraVariables}{For \code{selectSpectraVariables}: \code{character} with the
names of the spectra variables to which the backend should be subsetted.}
}
\value{
See documentation of respective function.
}
\description{
The \code{MsBackendWeizMass} provides access to WeizMass mass spectrometry
libraries by directly accessing its MySQL/MariaDb database. In addition the
backend supports adding new spectra variables to the object, or to \emph{locally}
change spectra variables (without changing the original values in the
database).

Note that \code{MsBackendWeizMass} requires access to a WeizMass MySQL/MariaDB
database.

Also, some of the fields in the WeizMass database are not directly compatible
with \code{Spectra}, as the data is stored as text instead of numeric. The
precursor m/z values are for example stored as character in the database, but
are converted to numeric during the data access. Thus, for spectra with
non-numeric values stored in that field an \code{NA} is reported.
}
\section{Supported Backend functions}{


The following functions are supported by the \code{MsBackendWeizMass}.
\itemize{
\item \code{[}: subset the backend. Only subsetting by element (\emph{row}/\code{i}) is
allowed
\item \code{$}, \verb{$<-}: access or set/add a single spectrum variable (column) in the
backend.
\item \code{acquisitionNum}: returns the acquisition number of each
spectrum. Returns an \code{integer} of length equal to the number of
spectra (with \code{NA_integer_} if not available).
\item \code{backendInitialize}: initialises the backend by retrieving the IDs of all
spectra in the database. Parameter \code{dbcon} with the connection to the
WeizMass MySQL database is required.
\item \code{dataOrigin}: gets a \code{character} of length equal to the number of spectra
in \code{object} with the \emph{data origin} of each spectrum. This could e.g. be
the mzML file from which the data was read.
\item \code{dataStorage}: returns \code{"<WeizMass>"} for all spectra.
\item \code{centroided}, \verb{centroided<-}: gets or sets the centroiding
information of the spectra. \code{centroided} returns a \code{logical}
vector of length equal to the number of spectra with \code{TRUE} if a
spectrum is centroided, \code{FALSE} if it is in profile mode and \code{NA}
if it is undefined. See also \code{isCentroided} for estimating from
the spectrum data whether the spectrum is centroided.  \code{value}
for \verb{centroided<-} is either a single \code{logical} or a \code{logical} of
length equal to the number of spectra in \code{object}.
\item \code{collisionEnergy}, \verb{collisionEnergy<-}: gets or sets the
collision energy for all spectra in \code{object}. \code{collisionEnergy}
returns a \code{numeric} with length equal to the number of spectra
(\code{NA_real_} if not present/defined), \verb{collisionEnergy<-} takes a
\code{numeric} of length equal to the number of spectra in \code{object}. Note that
the collision energy description from WeizMass are provided as spectra
variable \code{"collisionEnergyText"}.
\item \code{intensity}: gets the intensity values from the spectra. Returns
a \code{\link[=NumericList]{NumericList()}} of \code{numeric} vectors (intensity values for each
spectrum). The length of the \code{list} is equal to the number of
\code{spectra} in \code{object}.
\item \code{ionCount}: returns a \code{numeric} with the sum of intensities for
each spectrum. If the spectrum is empty (see \code{isEmpty}),
\code{NA_real_} is returned.
\item \code{isCentroided}: a heuristic approach assessing if the spectra in
\code{object} are in profile or centroided mode. The function takes
the \code{qtl} th quantile top peaks, then calculates the difference
between adjacent m/z value and returns \code{TRUE} if the first
quartile is greater than \code{k}. (See \code{Spectra:::.isCentroided} for
the code.)
\item \code{isEmpty}: checks whether a spectrum in \code{object} is empty
(i.e. does not contain any peaks). Returns a \code{logical} vector of
length equal number of spectra.
\item \code{isolationWindowLowerMz}, \verb{isolationWindowLowerMz<-}: gets or sets the
lower m/z boundary of the isolation window.
\item \code{isolationWindowTargetMz}, \verb{isolationWindowTargetMz<-}: gets or sets the
target m/z of the isolation window.
\item \code{isolationWindowUpperMz}, \verb{isolationWindowUpperMz<-}: gets or sets the
upper m/z boundary of the isolation window.
\item \code{isReadOnly}: returns a \code{logical(1)} whether the backend is \emph{read
only} or does allow also to write/update data.
\item \code{length}: returns the number of spectra in the object.
\item \code{lengths}: gets the number of peaks (m/z-intensity values) per
spectrum.  Returns an \code{integer} vector (length equal to the
number of spectra). For empty spectra, \code{0} is returned.
\item \code{msLevel}: gets the spectra's MS level. Returns an \code{integer}
vector (of length equal to the number of spectra) with the MS
level for each spectrum (or \code{NA_integer_} if not available).
\item \code{mz}: gets the mass-to-charge ratios (m/z) from the
spectra. Returns a \code{\link[=NumericList]{NumericList()}} or length equal to the number of
spectra, each element a \code{numeric} vector with the m/z values of
one spectrum.
\item \code{peaksData} returns a \code{list} with the spectras' peak data. The length of
the list is equal to the number of spectra in \code{object}. Each element of
the list is a \code{matrix} with columns defined by parameter \code{columns} which
defaults to \code{columns = c("mz", "intensity")} but any of
\code{peaksVariables(object)} would be supported.
Note that if \code{columns} contains \code{"peak_annotation"}, the whole matrix will
be of type \code{character} (i.e. even the m/z and intensity values will be
provided as text). See examples below for details. For an empty spectrum,
a \code{matrix} with 0 rows is returned.
\item \code{peaksVariables} returns a \code{character} with the provided peaks variables
(i.e. data available for each individual mass peak). These can be used in
\code{peaksData} to retrieve the specified values.
\item \code{polarity}, \verb{polarity<-}: gets or sets the polarity for each
spectrum.  \code{polarity} returns an \code{integer} vector (length equal
to the number of spectra), with \code{0} and \code{1} representing negative
and positive polarities, respectively. \verb{polarity<-} expects an
integer vector of length 1 or equal to the number of spectra.
\item \code{precursorCharge}, \code{precursorIntensity}, \code{precursorMz},
\code{precScanNum}, \code{precAcquisitionNum}: get the charge (\code{integer}),
intensity (\code{numeric}), m/z (\code{numeric}), scan index (\code{integer})
and acquisition number (\code{interger}) of the precursor for MS level
2 and above spectra from the object. Returns a vector of length equal to
the number of spectra in \code{object}. \code{NA} are reported for MS1
spectra of if no precursor information is available.
\item \code{reset}: restores the backend to its original state, i.e. deletes all
locally modified data and reinitializes the backend to the full data
available in the database.
\item \code{rtime}, \verb{rtime<-}: gets or sets the retention times for each
spectrum (in seconds). \code{rtime} returns a \code{numeric} vector (length equal to
the number of spectra) with the retention time for each spectrum.
\verb{rtime<-} expects a numeric vector with length equal to the
number of spectra.
\item \code{scanIndex}: returns an \code{integer} vector with the \emph{scan index}
for each spectrum. This represents the relative index of the
spectrum within each file. Note that this can be different to the
\code{acquisitionNum} of the spectrum which is the index of the
spectrum as reported in the mzML file.
\item \code{selectSpectraVariables}: reduces the information within the backend to
the selected spectra variables.
\item \code{smoothed},\verb{smoothed<-}: gets or sets whether a spectrum is
\emph{smoothed}. \code{smoothed} returns a \code{logical} vector of length equal
to the number of spectra. \verb{smoothed<-} takes a \code{logical} vector
of length 1 or equal to the number of spectra in \code{object}.
\item \code{spectraData}: gets general spectrum metadata (annotation, also called
header).  \code{spectraData} returns a \code{DataFrame}. Note that replacing the
spectra data with \verb{spectraData<-} is not supported.
\item \code{spectraNames}: returns a \code{character} vector with the names of
the spectra in \code{object}.
\item \code{spectraVariables}: returns a \code{character} vector with the
available spectra variables (columns, fields or attributes)
available in \code{object}. This should return \strong{all} spectra variables which
are present in \code{object}, also \code{"mz"} and \code{"intensity"} (which are by
default not returned by the \verb{spectraVariables,Spectra} method).
\item \code{tic}: gets the total ion current/count (sum of signal of a
spectrum) for all spectra in \code{object}. By default, the value
reported in the original raw data file is returned. For an empty
spectrum, \code{NA_real_} is returned.
}
}

\section{Not supported Backend functions}{


The following functions are not supported by the \code{MsBackendWeizMass} since
the original data can not be changed.

\code{backendMerge}, \code{export}, \code{filterDataStorage}, \code{filterPrecursorScan},
\verb{peaksData<-}, \code{filterAcquisitionNum}, \verb{intensity<-}, \verb{mz<-}, \code{precScanNum},
\verb{spectraData<-}, \verb{spectraNames<-}.
}

\section{Retrieving compound annotations for spectra}{


While compound annotations are also provided \emph{via} the \code{spectraVariables} of
the backend, it would also be possible to use the \code{compounds} function on
a \code{Spectra} object (that uses a \code{MsBackendWeizMass} backend) to retrieve
compound annotations for the specific spectra.
}

\examples{

## Create a connection to a database with WeizMass data - in the present
## example we connect to a tiny SQLite database bundled in this package.
library(RSQLite)
con <- dbConnect(SQLite(), system.file("sqlite", "weizmassv2.sqlite",
    package = "MsBackendWeizMass"))

## Given that we have the connection to a WeizMass database we can
## initialize the backend:
be <- backendInitialize(MsBackendWeizMass(), dbcon = con)
be

## List available peak variables
peaksVariables(be)

## Get peaks data; by default only m/z and intensity values are returned
peaksData(be)

## Get peaks data including peak annotations; note that now for each
## spectrum a character matrix is returned!
res <- peaksData(be, columns = c("mz", "intensity", "peak_annotation"))
res[[1L]]

## Get the m/z values for all spectra
mz(be)

## annotations for the invidual peaks can be retrieved with
be$peak_annotation

## List available spectra variables
spectraVariables(be)

## Access MS level
msLevel(be)
be$msLevel

## Access m/z values
be$mz

## Access the full spectra data (including m/z and intensity values)
spectraData(be)

## Add a new spectra variable
be$new_variable <- "b"
be$new_variable

## Subset the backend
be_sub <- be[c(2, 1)]

spectraNames(be)
spectraNames(be_sub)
}
\references{
Shahaf N., Rogachev I., Heinig U., Meir S, Malitsky S, Battat M. et al.
(2016). The WEIZMASS spectra library for high-confidence metabolite
identification. Nature Communications 7:12423. \doi{10.1038/ncomms12423}.
}
\author{
Johannes Rainer
}
